package feed

import (
	"expvar"
	"log"
	"strings"
	"sync"
	"time"

	telegram "github.com/jfk9w-go/telegram-bot-api"
	"github.com/jfk9w/hikkabot/format"
	"github.com/pkg/errors"
)

type Aggregator struct {
	Channel
	Context
	Storage
	Timeout  time.Duration
	Aliases  map[telegram.Username]telegram.ID
	Services []Service
	AdminID  telegram.ID
	metrics  *expvar.Map
	chats    map[telegram.ID]bool
	mu       sync.RWMutex
}

func (a *Aggregator) Init() *Aggregator {
	a.metrics = expvar.NewMap("aggregator")
	a.chats = make(map[telegram.ID]bool)
	for _, chatID := range a.Active() {
		a.RunFeed(chatID)
	}
	return a
}

func (a *Aggregator) runUpdater(chatID telegram.ID) {
	item := a.Advance(chatID)
	if item == nil {
		// no next item - subscriptions exhausted, stopping the updater
		a.mu.Lock()
		delete(a.chats, chatID)
		a.mu.Unlock()
		log.Printf("Stopped updater for %v", chatID)
		a.metrics.Add("active", -1)
		return
	}

	err := a.pullUpdates(chatID, item)
	if err != nil {
		if err == ErrNotFound {
			// the storage update has failed
			// meaning the subscription was suspended by external source
			// we don't need to do anything else
		} else {
			a.change(0, item.PrimaryID, Change{Error: err})
		}
	}

	// reschedule the updater
	time.AfterFunc(a.Timeout, func() { a.runUpdater(chatID) })
}

func (a *Aggregator) pullUpdates(chatID telegram.ID, item *ItemData) error {
	queue := newUpdateQueue()
	go queue.pull(a.Context, item.Offset, item)
	hasUpdates := false
	for update := range queue.updates {
		hasUpdates = true
		err := a.SendUpdate(chatID, update)
		if err != nil {
			return errors.Wrapf(err, "send update: %+v", update)
		}
		a.metrics.Add("updates", 1)
		err = a.change(0, item.PrimaryID, Change{Offset: update.Offset})
		if err != nil {
			queue.cancel <- struct{}{}
			close(queue.cancel)
			return err
		} else {
			log.Printf("Updated offset for %v: %v -> %v", item, item.Offset, update.Offset)
			item.Offset = update.Offset
		}
	}
	if queue.err != nil {
		return errors.Wrap(queue.err, "pull updates")
	}
	if !hasUpdates {
		if err := a.change(0, item.PrimaryID, Change{Offset: item.Offset}); err != nil {
			return err
		} else {
			log.Printf("Updated offset for %v: %v -> %v", item, item.Offset, item.Offset)
		}
	}
	return nil
}

func (a *Aggregator) RunFeed(chatID telegram.ID) {
	// check that the feed does not exist yet
	// via double-checked locking
	a.mu.RLock()
	ok := a.chats[chatID]
	a.mu.RUnlock()
	if ok {
		return
	}
	a.mu.Lock()
	if a.chats[chatID] {
		a.mu.Unlock()
		return
	}
	a.chats[chatID] = true
	a.mu.Unlock()
	// run updater
	go a.runUpdater(chatID)
	a.metrics.Add("active", 1)
	log.Printf("Started updater for %v", chatID)
}

var ErrNotFound = errors.New("not found")

func (a *Aggregator) change(userID telegram.ID, id string, change Change) error {
	var item *ItemData
	var ctx *changeContext
	if userID != 0 {
		// if the change is generated by a real user, check its privelege now and create the context
		item = a.Get(id)
		if item == nil {
			return ErrNotFound
		}
		ctx = &changeContext{chatID: item.ChatID}
		if err := ctx.checkAccess(a, userID); err != nil {
			return err
		}
	}
	ok := a.Storage.Update(id, change)
	if !ok {
		return ErrNotFound
	}
	if change.Offset != 0 {
		// if this is an offset update we don't need to notify admins
		return nil
	}
	if item == nil || ctx == nil {
		// if the change is generated by a system user, we need to create the context now
		item = a.Get(id)
		if item == nil {
			return ErrNotFound
		}
		ctx = &changeContext{chatID: item.ChatID}
	}
	if change.Error == nil {
		// if this is a "resume" event we want to ensure that the corresponding feed is runnning
		chat, err := ctx.getChat(a)
		if err != nil {
			return err
		}
		a.RunFeed(chat.ID)
	}

	// notifications
	adminIDs, err := ctx.getAdminIDs(a)
	if err != nil {
		return err
	}
	status := "OK ðŸ”¥"
	if change.Error != nil {
		status = "suspend"
	}

	title := "<private>"
	chat, _ := ctx.getChat(a)
	if chat.Type != telegram.PrivateChat {
		title = chat.Title
	}

	text := format.NewHTML(telegram.MaxMessageSize, 1, nil, nil).
		Text("Subscription " + status).NewLine().
		Text("Chat: " + title).NewLine().
		Text("Service: " + item.Service()).NewLine().
		Text("Item: " + item.Name())
	var button telegram.ReplyMarkup
	if change.Error != nil {
		button = telegram.CommandButton("Resume", "resume", item.PrimaryID)
		text.NewLine().
			Text("Reason: " + change.Error.Error())
	} else {
		button = telegram.CommandButton("Suspend", "suspend", item.PrimaryID)
	}

	go a.SendAlert(adminIDs, text.Format(), button)
	return nil
}

func (a *Aggregator) changeByUser(tg telegram.Client, c *telegram.Command, change Change) error {
	reply := "OK"
	if err := a.change(c.User.ID, c.Payload, change); err != nil {
		reply = err.Error()
	}
	_, err := tg.AnswerCallbackQuery(c.CallbackQueryID,
		&telegram.AnswerCallbackQueryOptions{Text: reply})
	return err
}

func (a *Aggregator) doCreate(c *telegram.Command) (err error) {
	fields := strings.Fields(c.Payload)
	cmd := fields[0]
	ctx := new(changeContext)
	if len(fields) > 1 && fields[1] != "." {
		username := telegram.Username(fields[1])
		var chatID telegram.ChatID = username
		if unaliased, ok := a.Aliases[username]; ok {
			chatID = unaliased
		}
		ctx.chatID = chatID
	} else {
		ctx.chatID = c.Chat.ID
		ctx.chat = c.Chat
	}
	err = ctx.checkAccess(a, c.User.ID)
	if err != nil {
		return
	}
	options := ""
	if len(fields) > 2 {
		options = fields[2]
	}
	for _, service := range a.Services {
		item := service()
		err = item.Parse(a.Context, cmd, options)
		switch err {
		case ErrParseFailed:
			continue
		case nil:
			idata := a.Storage.Create(ctx.chat.ID, item)
			if idata != nil {
				err = a.change(0, idata.PrimaryID, Change{})
			} else {
				err = errors.New("exists")
			}
			return
		default:
			break
		}
	}
	err = ErrParseFailed
	return
}

func (a *Aggregator) Create(tg telegram.Client, c *telegram.Command) error {
	err := a.doCreate(c)
	if err != nil {
		_, err = tg.Send(c.Chat.ID,
			&telegram.Text{Text: err.Error()},
			&telegram.SendOptions{ReplyToMessageID: c.MessageID})
	}
	return err
}

func (a *Aggregator) Resume(tg telegram.Client, c *telegram.Command) error {
	return a.changeByUser(tg, c, Change{})
}

var ErrSuspendedByUser = errors.New("suspended by user")

func (a *Aggregator) Suspend(tg telegram.Client, c *telegram.Command) error {
	return a.changeByUser(tg, c, Change{Error: ErrSuspendedByUser})
}

func (a *Aggregator) Status(tg telegram.Client, c *telegram.Command) error {
	text := format.NewHTML(telegram.MaxMessageSize, 0, nil, nil)
	if c.User.ID == a.AdminID {
		expvar.Do(func(kv expvar.KeyValue) {
			if kv.Key == "cmdline" || kv.Key == "memstats" {
				return
			}
			text.NewLine().Text(kv.Key + ": " + kv.Value.String())
		})
	} else {
		text.Text("OK")
	}
	a.SendAlert([]telegram.ID{c.Chat.ID}, text.Format(), nil)
	return nil
}

func (a *Aggregator) CommandListener() *telegram.CommandListener {
	return telegram.NewCommandListener().
		HandleFunc("/sub", a.Create).
		HandleFunc("resume", a.Resume).
		HandleFunc("suspend", a.Suspend).
		HandleFunc("/status", a.Status)
}
